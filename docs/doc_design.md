# Orion设计哲学

- Orion目的是为了加速业务开发,避免各个资业务重复造轮子而设计的.
- Orion抽离了必要的基础组件,但绝不是耦合各式各样轮子的工具集.
- Orion不是API网关,它只关注微服务底层的相关技术.
- Orion优雅编程实践,结合优雅的代码设计范式与模式,保证代码的可读性和可维护性.

# 思考:关于服务注册&发现

关于Orion的服务注册&发现这部分,作者思考了很久,从以下几个角度考虑:

1. Orion框架要不要集成服务发现与注册逻辑?
2. 要不要为Orion单独抽离设计一套微服务的控制面.

随着微服务的发展和普及,相较于传统的单体服务和SOA架构,微服务架构本身的优势还是比较明显的,比如:

1. 解耦复杂的业务逻辑,将相对独立的功能统一封装到对应的微服务里面,大大增加了组件复用的适用性.
2. 在微服务的升级和迭代上,对整体影响较小,只需要发布特定的微服务,提升了服务整体的可用性.
3. 结合完善的可观测性,通过微服务可以灵活地进行扩缩容,提升机器的利用率,优化成本.

当然,弊端也是有的,比如:

1. 对于小团队/小公司而言,微服务本身会增加开发成本,比如将一个小功能划分为n个独立的微服务时,需要维护的接口层会更多.
2. 需要搭建完善的可观测性架构,从而便于发现和解决服务运行过程中突发的问题.

Orion应当是灵活的,不管是小团队还是大企业应当都适用,作者的目标是完善相关生态:

- **Orion集成模式**,通过插件方式实现微服务的注册与发现(基于Consul或者其他分布式组件,更适用于小团队快速开发/部署).
- **Orion边车模式**,统一接管服务流量(适用于容器编排部署,需要有完善的云原生基础设施),在此模式下,服务熔断、限流等特性都可以从微服务框架本身抽离出来,让框架本身只关注业务.

# Orion相关术语

|术语|解释|
|:-|:-|
|`Balancer`|LB均衡器|
|`Resolver`|服务发现解析器|
|`Registry`|微服务注册器|
|`Interceptor`|拦截器|
|`CircuitBreaker`|熔断器|
|`RateLimiter`|限流器|